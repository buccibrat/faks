package hr.fer.zemris.java.hw03.prob1;

import hr.fer.zemris.java.hw03.prob1.Token;

/**
 * Tokeniezes string input.
 * 
 * @author Benjamin Ku≈°en
 *
 */
public class Lexer {
	/**
	 * Input that is tokenized by lexer.
	 */
	private char[] data;
	/**
	 * Last token that was generated by lexer.
	 */
	private Token token;
	/**
	 * Last index of data attribute that was analysed.
	 */
	private int currentIndex;
	/**
	 * State in which is lexer. State can be string or tag.
	 */
	private LexerState state;

	/**
	 * Converts input to array of characters. Sets state to basic.
	 * 
	 * @param text input
	 */
	public Lexer(String text) {
		if (text == null) {
			throw new NullPointerException();
		}
		data = text.toCharArray();
		currentIndex = 0;
		state = LexerState.BASIC;
	}

	/**
	 * Returns next token of input.
	 * 
	 * @return next token
	 */
	public Token nextToken() {
		if (state == LexerState.BASIC) {
			if (token != null && token.getType() == TokenType.EOF) {
				throw new LexerException();
			}

			if (data.length == 0) {
				token = new Token(TokenType.EOF, null);
				return token;
			}

			skipWhiteSpaces();

			if (data.length == currentIndex) {
				token = new Token(TokenType.EOF, null);
				return token;
			} else if (data[currentIndex] == '#') {
				return returnHash();
			} else if (Character.isLetter(data[currentIndex]) || data[currentIndex] == '\\') {

				String tokenString = new String();
				while (currentIndex < data.length && (Character.isLetter(data[currentIndex]) || isLetter())) {
					tokenString += data[currentIndex];
					currentIndex++;
				}

				token = new Token(TokenType.WORD, tokenString);
				return token;
			} else if (Character.isDigit(data[currentIndex])) {
				String tokenString = new String();
				while (currentIndex < data.length && Character.isDigit(data[currentIndex])) {
					tokenString += data[currentIndex];
					currentIndex++;
				}
				try {
					token = new Token(TokenType.NUMBER, Long.parseLong(tokenString));
				} catch (NumberFormatException e) {
					throw new LexerException();
				}
				return token;
			} else {
				if (data[currentIndex] == '#') {
					return returnHash();
				}
				token = new Token(TokenType.SYMBOL, data[currentIndex]);
				currentIndex++;
				return token;
			}
		} else {
			if (token != null && token.getType() == TokenType.EOF) {
				throw new LexerException();
			} else if (data.length == 0) {
				token = new Token(TokenType.EOF, null);
				return token;
			}

			skipWhiteSpaces();
			if (data.length == currentIndex) {
				token = new Token(TokenType.EOF, null);
				return token;
			}

			String tokenString = new String();

			while (currentIndex < data.length && data[currentIndex] != '#' && data[currentIndex] != ' ') {
				tokenString += data[currentIndex];
				currentIndex++;
			}
			if (tokenString.length() == 0 && data[currentIndex] == '#') {
				return returnHash();
			}
			if (currentIndex < data.length && data[currentIndex - 1] != '#') {
				token = new Token(TokenType.WORD, tokenString);
				return token;
			} else {
				return returnHash();
			}
		}

	}
	
	/**
	 * Returns last token generated by lexer
	 * @return token
	 */
	public Token getToken() {
		return token;
	}
	
	/**
	 * Sets state to state given to method.
	 * 
	 * @param state new state
	 */
	public void setState(LexerState state) {
		if (state == null) {
			throw new NullPointerException();
		}
		this.state = state;
	}
	 /**
	  * Checkes if character at current index is letter.
	  * @return
	  */
	private boolean isLetter() {

		if (data[currentIndex] == '\\' && currentIndex > data.length - 2) { // provjeravam jel se na kraju nalazi
			// backslash i bacam LexerException ako da
			throw new LexerException();
		} else if (data[currentIndex] == '\\' // provjeravam jel postoji backslash nakon kojeg ne dolazi niti backslash
				// niti digit, ako postoji bacam LexerException
				&& (data[currentIndex + 1] != '\\' && !Character.isDigit(data[currentIndex + 1]))) {
			throw new LexerException();
		} else if (data[currentIndex] == '\\') { // provjeravam jel iza backslash-a broj ili drugi backslash, ako je
			// ovaj backslash
			if (Character.isDigit(data[currentIndex + 1]) || data[currentIndex + 1] == '\\') {
				currentIndex++;
				return true;
			}
		}
		return false;
	}
	/**
	 * Skips white spaces.
	 */
	private void skipWhiteSpaces() {

		while (currentIndex < data.length && (data[currentIndex] == '\r' || data[currentIndex] == '\n'
				|| data[currentIndex] == '\t' || data[currentIndex] == ' ')) {
			currentIndex++;
		}

	}

	/**
	 * Switches state in which lexer works.
	 * 
	 * @return token with value #
	 */
	private Token returnHash() {
		if (state == LexerState.BASIC) {
			this.setState(LexerState.EXTENDED);
		} else {
			this.setState(LexerState.BASIC);
		}
		token = new Token(TokenType.SYMBOL, data[currentIndex]);
		currentIndex++;
		return token;
	}
}
